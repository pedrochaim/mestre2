---
title: "Índice de temas e microsubtemas"
format:
  html:
    toc: false
execute:
  echo: false
  warning: false
  message: false
---

```{r, results='asis'}
`%||%` <- function(a, b) if (is.null(a) || is.na(a) || a == "") b else a

# Caminho relativo entre dois caminhos absolutos
rel_path <- function(from, to) {
  from <- normalizePath(from, winslash = "/", mustWork = FALSE)
  to   <- normalizePath(to,   winslash = "/", mustWork = FALSE)
  fp <- strsplit(from, "/", fixed = TRUE)[[1]]
  tp <- strsplit(to,   "/", fixed = TRUE)[[1]]
  n  <- min(length(fp), length(tp))
  i  <- 0L
  while (i < n && fp[i + 1L] == tp[i + 1L]) i <- i + 1L
  ups  <- if ((length(fp) - i) > 0) rep("..", length(fp) - i) else "."
  rest <- if ((length(tp) - i) > 0) tp[(i + 1L):length(tp)] else character(0)
  parts <- c(if (!identical(ups, ".")) ups else character(0), rest)
  if (length(parts)) paste(parts, collapse = "/") else "."
}

# Lista hardcoded de <tema_clean>
temas_validos <- c(
  "artes","ciencias","cotidiano","entretenimento","esportes",
  "geografia","historia","historia_natural","variedades"
)

# Raiz do repositório e diretório deste arquivo
env_root  <- Sys.getenv("MESTRE2_ROOT", unset = "")
this_file <- tryCatch(knitr::current_input(), error = function(e) "") %||% "info/lista_microsubtemas.qmd"
this_dir  <- normalizePath(dirname(this_file), winslash = "/", mustWork = FALSE)
repo_root <- normalizePath(if (nzchar(env_root)) env_root else file.path(this_dir, ".."),
                           winslash = "/", mustWork = FALSE)

# Busca por pastas subtemas_<tema_clean>
all_dirs <- list.dirs(repo_root, recursive = TRUE, full.names = TRUE)
is_subdir <- grepl("^subtemas_[a-z0-9_]+$", basename(all_dirs), perl = TRUE)
dirs_hit  <- unique(normalizePath(all_dirs[is_subdir], winslash = "/", mustWork = FALSE))

slugs_encontrados <- sort(unique(sub("^subtemas_", "", basename(dirs_hit))))
slugs_validos     <- sort(intersect(slugs_encontrados, temas_validos))
slugs_nao_prev    <- sort(setdiff(slugs_encontrados, temas_validos))
slugs_faltando    <- sort(setdiff(temas_validos, slugs_encontrados))

# Cabeçalho
cat("**Raiz usada:** `", repo_root, "`\n\n", sep = "")
cat("**Padrão de pasta:** `subtemas_<tema_clean>`\n\n")

# Lista de <tema_clean> encontrados (válidos)
cat("## <tema_clean> encontrados (válidos)\n\n")
if (length(slugs_validos) == 0) {
  cat("_Nenhum._\n\n")
} else {
  for (s in slugs_validos) cat("- `", s, "`\n", sep = "")
  cat("\n")
}

# Avisos
if (length(slugs_nao_prev) > 0 || length(slugs_faltando) > 0) {
  cat("## Avisos\n\n")
  if (length(slugs_nao_prev) > 0) {
    cat("**Não previstos na lista hardcoded:**\n\n")
    for (s in slugs_nao_prev) cat("- `", s, "`\n", sep = "")
    cat("\n")
  }
  if (length(slugs_faltando) > 0) {
    cat("**Esperados mas não encontrados:**\n\n")
    for (s in slugs_faltando) cat("- `", s, "`\n", sep = "")
    cat("\n")
  }
}

# Acumulador global (para salvar JSON canônico ao final)
canon_pairs <- data.frame(
  tema_clean    = character(),
  subtema_clean = character(),
  stringsAsFactors = FALSE
)

# Para cada <tema_clean>, listar <subtema_clean> com link
if (length(slugs_validos) > 0) cat("## Microsubtemas por tema\n\n")

for (slug in slugs_validos) {
  pastas_slug <- dirs_hit[basename(dirs_hit) == paste0("subtemas_", slug)]

  # acumulador: named character vector {name=subtema_clean, value=path}
  subtema_map <- character(0)

  for (pasta in pastas_slug) {
    arquivos <- list.files(
      pasta,
      pattern = paste0("^microsubtemas_", slug, "_[a-z0-9_]+\\.md$"),
      full.names = TRUE, recursive = FALSE
    )
    if (length(arquivos)) {
      subts <- sub(paste0("^microsubtemas_", slug, "_([a-z0-9_]+)\\.md$"),
                   "\\1", basename(arquivos), perl = TRUE)
      names(arquivos) <- subts
      # dedup dentro do lote atual
      arquivos <- arquivos[!duplicated(names(arquivos))]
      # agrega
      subtema_map <- c(subtema_map, arquivos)
    }
  }

  # DEDUP FINAL (crítico para evitar repetições consecutivas)
  if (length(subtema_map)) {
    subtema_map <- subtema_map[!duplicated(names(subtema_map))]
    subtema_map <- subtema_map[order(names(subtema_map))]
  }

  cat("### ", slug, "\n\n", sep = "")
  if (!length(subtema_map)) {
    cat("_Nenhum arquivo `microsubtemas_", slug, "_<subtema_clean>.md` encontrado._\n\n", sep = "")
  } else {
    for (st in names(subtema_map)) {
      link_rel <- rel_path(this_dir, subtema_map[[st]])
      cat(sprintf("- [`%s`](%s)\n", st, link_rel))
    }
    cat("\n")
  }

  # Agrega pares (tema_clean, subtema_clean) para a lista canônica
  if (length(subtema_map)) {
    canon_pairs <- rbind(
      canon_pairs,
      data.frame(
        tema_clean    = slug,
        subtema_clean = names(subtema_map),
        stringsAsFactors = FALSE
      )
    )
  }
}

# ---- Salvar JSON canônico com (tema_clean, subtema_clean) -------------------

# Deduplifica globalmente e ordena
if (nrow(canon_pairs)) {
  canon_pairs <- unique(canon_pairs)
  canon_pairs <- canon_pairs[order(canon_pairs$tema_clean, canon_pairs$subtema_clean), , drop = FALSE]
}

# Local de saída: diretório CORRENTE (onde está este .qmd)
out_dir  <- this_dir
suppressWarnings(dir.create(out_dir, recursive = TRUE, showWarnings = FALSE))
out_path <- normalizePath(file.path(out_dir, "canon_temas_subtemas.json"), winslash = "/", mustWork = FALSE)
out_rel  <- rel_path(this_dir, out_path)

# Função simples de escape JSON (fallback)
json_escape <- function(s) {
  s <- gsub("\\\\", "\\\\\\\\", s, perl = TRUE)
  s <- gsub('"', '\\"', s, perl = TRUE)
  s
}

# Escreve JSON usando jsonlite se disponível; caso contrário, fallback manual
wrote_ok <- FALSE
if (requireNamespace("jsonlite", quietly = TRUE)) {
  try({
    jsonlite::write_json(canon_pairs, out_path, pretty = TRUE, auto_unbox = TRUE)
    wrote_ok <- TRUE
  }, silent = TRUE)
}
if (!wrote_ok) {
  # Constrói JSON manualmente (array de objetos)
  if (nrow(canon_pairs) == 0) {
    txt <- "[]"
  } else {
    rows <- apply(canon_pairs, 1, function(r) {
      sprintf('{"tema_clean":"%s","subtema_clean":"%s"}',
              json_escape(r[[1]]), json_escape(r[[2]]))
    })
    txt <- paste0("[\n  ", paste(rows, collapse = ",\n  "), "\n]")
  }
  writeLines(txt, out_path, useBytes = TRUE)
}

cat("## Arquivo canônico salvo\n\n")
cat("- **Caminho:** `", out_rel, "`\n", sep = "")
cat("- **Pares (tema_clean, subtema_clean):** ", nrow(canon_pairs), "\n\n", sep = "")
cat("_O JSON foi salvo no diretório corrente deste arquivo (.qmd)._ \n")
```
